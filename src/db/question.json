[
  {
    "id": "q1",
    "title": "프로그래밍 기능사",
    "question": "C언어에서 지역 변수(local variable)에 대한 설명으로 옳은 것은?",
    "choices": [
      "프로그램 실행 동안 항상 메모리에 유지된다.",
      "함수가 호출될 때 생성되고 함수가 종료되면 소멸한다.",
      "정적 영역(.data)에 저장된다.",
      "다른 소스 파일에서도 extern으로 접근 가능하다."
    ],
    "answerIndex": 1,
    "explanation": "지역 변수는 보통 스택 영역에 저장되며 함수 호출 시 생성되고 함수 종료 시 소멸한다."
  },
  {
    "id": "q2",
    "title": "프로그래밍 기능사",
    "question": "다음 C 코드에서 출력 결과는?\n\nint a = 5;\nprintf(\"%d\", a++ + ++a);\n",
    "choices": [
      "11",
      "12",
      "13",
      "정의되지 않은 동작(Undefined Behavior)"
    ],
    "answerIndex": 3,
    "explanation": "하나의 표현식에서 같은 변수를 여러 번 변경하고 그 사이의 순서가 보장되지 않으면 C에서 정의되지 않은 동작이 된다."
  },
  {
    "id": "q3",
    "title": "프로그래밍 기능사",
    "question": "다음 중 포인터 p가 가리키는 값에 1을 더하는 올바른 C 코드는?",
    "choices": [
      "p = p + 1;",
      "*p = *p + 1;",
      "&p = &p + 1;",
      "*p++"
    ],
    "answerIndex": 1,
    "explanation": "*p는 p가 가리키는 값이므로 그 값에 1을 더하려면 *p = *p + 1; 이다."
  },
  {
    "id": "q4",
    "title": "프로그래밍 기능사",
    "question": "C언어에서 문자열 \"ABC\"를 저장하기 위한 배열 선언으로 가장 적절한 것은?",
    "choices": [
      "char s[3] = \"ABC\";",
      "char s[4] = \"ABC\";",
      "char s[3] = {'A','B','C','\\0'};",
      "char s[] = {'A','B','C'};"
    ],
    "answerIndex": 1,
    "explanation": "문자열은 마지막에 널 문자(\\0)가 필요하므로 \"ABC\"는 총 4칸이 필요하다."
  },
  {
    "id": "q5",
    "title": "프로그래밍 기능사",
    "question": "다음 중 C언어에서 동적 메모리 할당 후 반드시 수행해야 하는 작업은?",
    "choices": [
      "free로 해제한다.",
      "malloc 전에 memset으로 초기화한다.",
      "포인터에 주소를 더해준다.",
      "동적 할당한 메모리는 자동으로 소멸한다."
    ],
    "answerIndex": 0,
    "explanation": "malloc/calloc/realloc으로 할당한 메모리는 사용 후 free로 해제해야 한다."
  },
  {
    "id": "q6",
    "title": "프로그래밍 기능사",
    "question": "다음 중 파일 입출력에서 파일을 읽기 전용으로 여는 모드는?",
    "choices": [
      "\"w\"",
      "\"a\"",
      "\"r\"",
      "\"rb+\""
    ],
    "answerIndex": 2,
    "explanation": "\"r\"은 읽기 전용으로 파일을 연다. \"w\"는 쓰기(덮어쓰기), \"a\"는 추가, \"rb+\"는 읽기/쓰기 바이너리 모드이다."
  },
  {
    "id": "q7",
    "title": "프로그래밍 기능사",
    "question": "다음 중 운영체제에서 프로세스 상태가 아닌 것은?",
    "choices": [
      "Ready",
      "Running",
      "Waiting",
      "Compiling"
    ],
    "answerIndex": 3,
    "explanation": "Compiling은 프로세스 상태가 아니다. 일반적으로 Ready, Running, Waiting(Blocked) 등이 있다."
  },
  {
    "id": "q8",
    "title": "프로그래밍 기능사",
    "question": "다음 중 교착상태(Deadlock)의 필요 조건 4가지에 포함되지 않는 것은?",
    "choices": [
      "상호 배제(Mutual Exclusion)",
      "점유와 대기(Hold and Wait)",
      "비선점(No Preemption)",
      "우선순위 역전(Priority Inversion)"
    ],
    "answerIndex": 3,
    "explanation": "교착상태 필요조건은 상호배제, 점유와대기, 비선점, 순환대기이다. 우선순위 역전은 별개의 문제다."
  },
  {
    "id": "q9",
    "title": "프로그래밍 기능사",
    "question": "다음 중 데이터베이스에서 후보키(Candidate Key)의 성질로 옳은 것은?",
    "choices": [
      "유일성과 최소성을 동시에 만족한다.",
      "유일성만 만족하면 된다.",
      "최소성만 만족하면 된다.",
      "외래키를 포함해야 한다."
    ],
    "answerIndex": 0,
    "explanation": "후보키는 튜플을 유일하게 식별(유일성)하며 불필요한 속성을 제거한 최소성도 만족한다."
  },
  {
    "id": "q10",
    "title": "프로그래밍 기능사",
    "question": "다음 SQL 중 dept가 'SALES'인 행만 조회하는 올바른 조건은?",
    "choices": [
      "WHERE dept = SALES",
      "WHERE dept == 'SALES'",
      "WHERE dept = 'SALES'",
      "WHERE dept IS 'SALES'"
    ],
    "answerIndex": 2,
    "explanation": "문자열 비교는 작은따옴표를 사용하며 SQL에서는 = 연산자를 사용한다."
  },
  {
    "id": "q11",
    "title": "프로그래밍 기능사",
    "question": "다음 중 정규화(Normalization)의 목적으로 가장 적절한 것은?",
    "choices": [
      "데이터 중복을 최소화하고 이상 현상을 줄인다.",
      "조회 성능을 위해 모든 테이블을 하나로 합친다.",
      "인덱스를 제거하여 저장 공간을 줄인다.",
      "항상 조인 횟수를 늘려 데이터 무결성을 확보한다."
    ],
    "answerIndex": 0,
    "explanation": "정규화는 데이터 중복과 삽입/삭제/갱신 이상을 줄여 무결성을 높이는 것이 목적이다."
  },
  {
    "id": "q12",
    "title": "프로그래밍 기능사",
    "question": "다음 중 스택(Stack)의 특징으로 옳은 것은?",
    "choices": [
      "FIFO 구조이다.",
      "LIFO 구조이다.",
      "임의 위치 삽입이 빠르다.",
      "삭제 연산이 항상 O(n)이다."
    ],
    "answerIndex": 1,
    "explanation": "스택은 LIFO(Last-In First-Out) 구조로, 마지막에 넣은 것이 먼저 나온다."
  },
  {
    "id": "q13",
    "title": "프로그래밍 기능사",
    "question": "다음 중 이진 탐색(Binary Search)을 수행하기 위한 전제 조건은?",
    "choices": [
      "데이터가 무작위로 섞여 있어야 한다.",
      "데이터가 정렬되어 있어야 한다.",
      "데이터가 중복이 없어야 한다.",
      "데이터가 연결 리스트여야 한다."
    ],
    "answerIndex": 1,
    "explanation": "이진 탐색은 정렬된 자료에서만 유효하다."
  },
  {
    "id": "q14",
    "title": "프로그래밍 기능사",
    "question": "다음 중 해시(Hash)의 일반적인 특징으로 옳은 것은?",
    "choices": [
      "항상 삽입/검색/삭제가 O(log n)이다.",
      "충돌(Collision)이 발생할 수 있다.",
      "정렬된 순서로 데이터가 저장된다.",
      "최악의 경우에도 O(1)이 보장된다."
    ],
    "answerIndex": 1,
    "explanation": "해시는 해시 함수에 따라 충돌이 발생할 수 있으며, 최악의 경우 성능이 나빠질 수 있다."
  },
  {
    "id": "q15",
    "title": "프로그래밍 기능사",
    "question": "다음 중 네트워크에서 TCP의 특징으로 옳은 것은?",
    "choices": [
      "비연결형이며 신뢰성을 보장하지 않는다.",
      "연결형이며 신뢰성을 보장한다.",
      "UDP보다 헤더가 단순하고 빠르다.",
      "브로드캐스트에 최적화되어 있다."
    ],
    "answerIndex": 1,
    "explanation": "TCP는 연결형 프로토콜로 신뢰성(순서 보장, 재전송 등)을 제공한다."
  },
  {
    "id": "q16",
    "title": "프로그래밍 기능사",
    "question": "다음 중 IP 주소에 대한 설명으로 옳은 것은?",
    "choices": [
      "MAC 주소는 논리 주소이고 IP는 물리 주소이다.",
      "IP는 네트워크 계층의 논리 주소이다.",
      "IP는 데이터 링크 계층에서 사용된다.",
      "IP는 항상 48비트 길이이다."
    ],
    "answerIndex": 1,
    "explanation": "IP는 네트워크 계층에서 사용되는 논리 주소이며 MAC은 데이터 링크 계층의 물리 주소이다."
  },
  {
    "id": "q17",
    "title": "프로그래밍 기능사",
    "question": "다음 중 컴파일 과정의 일반적인 순서로 가장 적절한 것은?",
    "choices": [
      "어셈블링 → 전처리 → 컴파일 → 링크",
      "전처리 → 컴파일 → 어셈블링 → 링크",
      "컴파일 → 전처리 → 링크 → 어셈블링",
      "링크 → 전처리 → 컴파일 → 어셈블링"
    ],
    "answerIndex": 1,
    "explanation": "일반적으로 전처리 후 컴파일, 어셈블링, 링크 순으로 진행된다."
  },
  {
    "id": "q18",
    "title": "프로그래밍 기능사",
    "question": "다음 중 UML 다이어그램 중에서 객체 간 상호작용(메시지 흐름)을 시간 순서대로 표현하는 것은?",
    "choices": [
      "클래스 다이어그램(Class Diagram)",
      "시퀀스 다이어그램(Sequence Diagram)",
      "유스케이스 다이어그램(Use Case Diagram)",
      "컴포넌트 다이어그램(Component Diagram)"
    ],
    "answerIndex": 1,
    "explanation": "시퀀스 다이어그램은 객체 간 메시지 흐름을 시간 순서대로 표현한다."
  },
  {
    "id": "q19",
    "title": "프로그래밍 기능사",
    "question": "다음 중 소프트웨어 테스트에서 '화이트박스 테스트'의 설명으로 옳은 것은?",
    "choices": [
      "내부 구조를 모른 채 기능 요구사항만으로 테스트한다.",
      "내부 구조를 알고 경로/분기 등을 기반으로 테스트한다.",
      "사용자 관점의 인수 테스트를 의미한다.",
      "성능 테스트만을 의미한다."
    ],
    "answerIndex": 1,
    "explanation": "화이트박스 테스트는 내부 구조를 알고 코드 경로, 분기, 조건 등을 기반으로 테스트한다."
  },
  {
    "id": "q20",
    "title": "프로그래밍 기능사",
    "question": "다음 중 스케줄링 알고리즘에 대한 설명으로 옳은 것은?",
    "choices": [
      "FCFS는 항상 평균 대기 시간이 가장 짧다.",
      "SJF는 평균 대기 시간을 최소화하는 경향이 있다.",
      "Round Robin은 선점이 불가능하다.",
      "Priority Scheduling은 기아(Starvation)가 발생하지 않는다."
    ],
    "answerIndex": 1,
    "explanation": "SJF(Shortest Job First)는 평균 대기 시간을 최소화하는 경향이 있으나, 긴 작업의 기아 문제가 생길 수 있다."
  }
]